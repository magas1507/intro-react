Si React es tu primera liber√≠a de JavaScript, debes saber que muchas de las librer√≠as est√°n basadas en componentes, pero‚Ä¶ ¬øRealmente qu√© significa un ‚Äúcomponente‚Äù? Si ya has tomado el Curso B√°sico de Web Components con JavaScript pues el concepto es pr√°cticamente el mismo, pero aplicados a React. Pero si es la primera vez que escuchas sobre componentes‚Ä¶
.
‚òù B√°sicamente un componente es un pedacito de tu p√°gina web, es decir, puede ser una secci√≥n espec√≠fica de tu p√°gina web, o puede ser alg√∫n elemento que se repita m√∫ltiples veces en la misma. Lo importante a tener en cuenta es que, un componente es una parte espec√≠fica de tu p√°gina, es algo que cumple una acci√≥n simple üëÄ.
.
¬øEl header de mi p√°gina puede ser un componente? ¬°S√≠!
¬øEl sidebar puede ser un componente? ¬°Por su puesto!
Y si tengo varios articulos en mi p√°gina‚Ä¶ ¬øPuedo convertirlos a componentes? ¬°Por su pollo! üòÑ
.
Recuerda que todo puede ser un componente, y esto nos permite modularizar nuestro c√≥digo. Es decir, podemos dividir y ‚Äúaislar‚Äù cada parte de nuestra p√°gina. Si por alguna raz√≥n necesitaramos actualizar nuestro header (por ejemplo), bastar√≠a con entrar al componente header modificar una peque√±a l√≠nea y listo! Ya no tendr√≠amos que buscar el header dentro de tooooodo nuestro HTML UwU.
.
üëÄ Otra ventaja de los componentes es que son reutilizables, es decir, puedes usarlos cuantas veces quieras. Por ejemplo, si tuvieras un sitio web sobre blogs, ya sabes que muchos blogs suelen tener una imagen, un t√≠tulo y una descripci√≥n. Entonces podr√≠amos crear un componente con la estructura de nuestro blogpost y √∫nicamente mandarle la informaci√≥n que necesitemos por cada blogpost y cada uno se crear√≠a autom√°ticamente!!

clase 2**

Recuerden que para inicializar un proyecto de react con configuraciones predeterminadas, esto dentro de la carpeta en la que estamos introducimos el siguiente c√≥digo en la terminal:

npx create-react-app ./
Recuerden que el " ./ " hace referencia a la carpeta en la cual nos encontramos posicionados dentro de la terminal

***clase 3
Lo incre√≠ble de JSX es que ahora estamos practicamente escribiendo todo el HTML de nuestra aplicaci√≥n dentro de JavaScript üòé. 
A esto es a lo que nos referimos cuando decimos que ‚Äúhoy en d√≠a nuestras aplicaciones web ya son puro JavaScript‚Äù.
Aunque la verdadera forma de trabajar con JSX es usando la funci√≥n createElement, esta suggar syntax nos permite verlo m√°s parecido a un HTML (lo cual tambi√©n lo hace m√°s legible).
 Y ahora casi que podemos mezclar HTML con JavaScript. 
Es decir, podemos tener nuestra l√≥gica de JavaScript y despu√©s en el render de JSX podemos simplemente usar variables (o usar directamente c√≥digo JavaScript).
.
Of course‚Ä¶ empiezan a entrar en juego las buenas practicas, ya que si miramos el hecho de que React nos permite combinar c√≥digo JavaScript con nuestro HTML nos empezamos a dar cuenta que‚Ä¶ 
pues se va pareciendo un poquito a lo que hacian los programadores de anta√±o con HTML y PHP y el c√≥digo acababa siendo una mezcla rara de dos lenguajes üòÖ. 
Tambi√©n por eso es importante mantener separada la vista de nuestra l√≥gica en nuestras aplicaciones. 
En fin, el punto es que JSX nos permite escribir nuestra vista con una sintaxis muy parecida a HTML, pero con la oportunidad de incluir nuestro c√≥digo JavaScript dentro, lo cual hace m√°s f√°cil de entender qu√© hace cada componente üòâ.

/***Eventos en React*/
‚òù Por si no entendiste bien por qu√© a veces enviamos arrow functions y por qu√© otras veces no, aqu√≠ te lo explico:
.
Cualquier evento recibe s√≠ o s√≠ una funci√≥n, es decir, debemos mandarle s√≠ o s√≠ una funci√≥n para que React internamente pueda ejecutarla en cuanto dicho eventop ocurre.
.
El asunto, es que tiene que ser s√≠ o s√≠ una funci√≥n que React pueda ejecutar, por eso no podemos mandar directamente un console.log() ni un alert(), porque aunque ambos son funciones, nosotros estamos ejecut√°ndolas directamente al ponerles los par√©ntesis, pero nosotros no debemos ejecutarlas, nosotros solo debemos mandarlas y ya React se encargar√° de ejecutarlas.
.
Es por eso que mandamos arrow functions, porque estas son funciones que React puede ejecutar cuando quiera, y pues dentro de esas arrow functions est√° el c√≥digo que queremos ejecutar cuando el evento suceda.
.

onClick={() => alert("React s√≠ puede ejecutar esta arrow function cada que le de la gana OwO")}
.
Sin embargo, recordando que los eventos reciben funciones, yo puedo crear una variable que dentro guarde una funci√≥n, por ejemplo:
.

const adentroTengoUnaFuncion = () => {
    console.log("Hola");
    console.log("Soy una funci√≥n que est√° siendo guardada dentro de una variable UwU");
}
.
Yo puedo ejecutar esta funci√≥n sin problemas de esta forma adentroTengoUnaFuncion(), pero tambi√©n puedo mandarsela a React para que √©l lo ejecute cuando quiera (en este caso, cuando el evento suceda):
.

onClick={adentroTengoUnaFuncion}
.
Nota como aqu√≠ mandamos la funci√≥n sin par√©ntesis, esto es porque en el momento en el que le ponemos par√©ntesis ser√≠amos nosotros quienes ejecutan la funci√≥n, pero recuerda que nosotros no debemos ejecutar la funci√≥n, sino React es quien tiene que ejecutarla. ¬øPor qu√©? Pues porque si la ejecutamos nosotros, esta se va a ejecutar justo en el momento que esa l√≠nea de c√≥digo sea le√≠da por nuestra computadora, y nosotros no queremos eso, nosotros queremos que nuestra funci√≥n se ejecute √∫nicamente cuando el evento suceda, por eso la mandamos sin par√©ntesis, para que React pueda ejecutarla cuando dicho evento ocurra üòÑ
.
Peeeeeero, podemos hacer algo genial (y puede ponerse complicado), no veo raz√≥n para hacer esto, pero te lo explico por alimentar tu curiosidad jaja:
.
S√≠ podemos ejecutar nosotros la funci√≥n üëÄ‚Ä¶ Yo s√©, esto es totalmente lo contrario a lo que te acabo de decir, pero checa esto üëá
.
Nosotros s√≠ podemos hacer esto:
.

onClick={adentroTengoUnaFuncion()}
Solamente s√≠ nuestra funci√≥n est√° as√≠:
.

const adentroTengoUnaFuncion = () => {
    return () => {
        console.log("Hola");
        console.log("Soy una funci√≥n que est√° siendo guardada dentro de una variable UwU");
    }
}
.
Wait‚Ä¶ what? Es simple üëÄ Mi funci√≥n adentroTengoUnaFuncion est√° retornando otra funci√≥n, eso significa que, en el momento que mi c√≥digo se ejecute, mi funci√≥n adentroTengoUnaFuncion tambi√©n se va a ejecutar inmediatamente, pero como esta funci√≥n est√° retornando otra funci√≥n, al final mi evento onClick acabar√° recibiendo la funci√≥n que necesita para funcionar!!! OwO
.
¬øPor qu√© har√≠amos esto? Seguramente tenga alg√∫n caso de uso, pero tambi√©n es interesante saber que se pueden hacer este tipo de cosas UwU

***/Manejo de Estado en React*/

Para poder manejar los estados, vamos a necesitar de react el useState.

//Si quieres importar todo React para usar useState
import React from 'react';
//Lo vas a usar de esta forma:
const [searchValue, setSearchValue] = React.useState('')

//Si quieres importar unicamente useState
import { useState } from 'react';
//Lo vas a usar de esta forma: 
const [searchValue, setSearchValue] = useState('')
useState tiene dos elementos:

El valor (quien seria value)
La funcion que cambia el valor (quien seria setValue)
En useState es siempre necesario definir un valor como parametro. Puede ser un string, array, booleano o n√∫mero

const [searchValue, setSearchValue] = useState('')
const [searchValue, setSearchValue] = useState(false)
const [searchValue, setSearchValue] = useState(['Dorime', 'Ameno'])
const [searchValue, setSearchValue] = useState(0)
En la etiqueta donde vamos a manejar el evento, no debemos olvidar colocar el value que recibir√° el valor de useState. Ejemplo:

<input
  className="TodoSearch"
  placeholder="Ingresa un POYO Todo"
  value={searchValue}
	onChange={onSearchValueChange}
/>
Espero que les haya ayudado üåü .


/***API de almacenamiento web**/

localStorage: guarda la informaci√≥n en memoria incluso cuando el navegador se cierre y se reabra.

sesionStorage: uarda la informacion en memoria mientras dure la sesi√≥n de la p√°gina.

Storage.setItem()
cuando recibe un nombre y valor, lo almacena o actualiza si ya existe.

Ejemplo:

storage.setItem(nombre, valor);

Storage.getItem()
Devuelve el valor cuando le pasamos el nombre.

Ejemplo

let userBackground = storage.getItem(userBackground); 

// #000000

Storage.removeItem()
Elimina el valor almacenado cuando le pasamos el nombre:

Ejemplo

let userBackground = storage.removeItem(userBackground); 

// Queda el valor por defecto en caso que exista, por lo ejemplo un background blanco.

Storage.length
Devuelve un entero que indica el n√∫mero de elementos guardados en el objeto ** Storage.**

Ejemplo

function userSettings() {
  localStorage.setItem('userBackground', '#000000');
  localStorage.setItem('font', comic sans');
  localStorage.setItem('fontSize', '18');

  localStorage.length;

 // 3
}

storage.clear();
borra todos los registros guardados en local.

*** Como aprendimos en el minuto 04:57, podemos enviarle un segundo argumento a la funci√≥n useEffect para determinar cu√°ndo ejecutamos o 
no el c√≥digo de nuestro efecto.
.
üîÇ Podemos enviar un array vac√≠o para decirle a nuestro efecto solo se ejecute una vez, 
cuando reci√©n hacemos el primer render de nuestro componente.
.
üëÇ O tambi√©n podemos enviar un array con distintos elementos para decirle a nuestro efecto que no solo ejecute el efecto en el primer render, 
sino tambi√©n cuando haya cambios en esos elementos del array.
.
üîÅ Si no enviamos ning√∫n array como segundo argumento de nuestro efecto, 
esta funci√≥n se ejecutar√° cada vez que nuestro componente haga render (es decir, cada vez que haya cambios en cualquiera de nuestros estados).
.
.
‚ùì ¬øCu√°l de estas opciones crees que debimos usar en nuestro efecto dentro de useLocalStorage?
.
Al menos por ahora, lo mejor habr√≠a sido enviar un array vac√≠o para que nuestro efecto solo se ejecute una vez, 
en el primer amado a nuestro custom hook / render de nuestro componente. üòå
.
Lastimosamente, olvid√© escribir ese segundo par√°metro durante la clase. 
Esto hace que el c√≥digo de mi efecto se ejecute cada vez que hay un cambio en el estado. Y como hacemos cambios a estado dentro del efecto, 
entonces el efecto se ejecutar√° sin parar todo el tiempo que usemos la aplicaci√≥n. üò±.
Afortunadamente, como todo el c√≥digo del useEffect est√° envuelto en un setTimeout, 
cada ejecuci√≥n del c√≥digo de efecto tarda 1 segundo en volver a ejecutarse, por lo que la app no va a crashear. üòì
.
¬°Este error podemos resolverlo en el siguiente curso de la saga! üôè
Incluso podemos profundizar much√≠simo m√°s en este tipo de errores en un curso de optimizaci√≥n, rendimiento y debugging con React.js. üíö
.
.
üí™ Mientras tanto, s√© mejor que yo. No olvides escribir el segundo par√°metro de tu efecto en useLocalStorage para que el c√≥digo de tu efecto solo se ejecute una vez y no tengas problemas de rendimiento en tu versi√≥n de TODO Machine.

***Aprovecho para aclar√°rselos:

Una cosa es el render de React. Y otra cossa es el render en el navegador.

React ejecuta el useEffect luego del render de React, pero antes del render en el navegador.

En cambio, React ejecuta el useLayoutEffect luego del render de React y del render en el navegador.

Pregunta de examen. üòÑ

**Recuerda que cuando hay mas de un estado ya no vamos a pasar un array con todos ellos, si no un objeto

¬øQu√© hace useEffect? Al usar este Hook, le estamos indicando a React que el componente tiene que hacer algo despu√©s de renderizarse. React recordar√° la funci√≥n que le hemos pasado (nos referiremos a ella como nuestro ‚Äúefecto‚Äù), y la llamar√° m√°s tarde despu√©s de actualizar el DOM. En este efecto, actualizamos el t√≠tulo del documento, pero tambi√©n podr√≠amos hacer peticiones de datos o invocar alguna API imperativa.

¬øPor qu√© se llama a useEffect dentro del componente? Poner useEffect dentro del componente nos permite acceder a la variable de estado count (o a cualquier prop) directamente desde el efecto. No necesitamos una API especial para acceder a ella, ya que se encuentra en el √°mbito de la funci√≥n. Los Hooks aprovechan los closures de JavaScript y evitan introducir APIs espec√≠ficas de React donde JavaScript ya proporciona una soluci√≥n.

¬øSe ejecuta useEffect despu√©s de cada renderizado? ¬°S√≠! Por defecto se ejecuta despu√©s del primer renderizado y despu√©s de cada actualizaci√≥n. M√°s tarde explicaremos c√≥mo modificar este comportamiento. En vez de pensar en t√©rminos de ‚Äúmontar‚Äù y ‚Äúactualizar‚Äù, puede resultarte m√°s f√°cil pensar en efectos que ocurren ‚Äúdespu√©s del renderizado‚Äù. React se asegura de que el DOM se ha actualizado antes de llevar a cabo el efecto.



***React Context: estado compartido***

Context
Context provee una forma de pasar datos 
a trav√©s del √°rbol de componentes sin tener 
que pasar props manualmente en cada nivel.

En una aplicaci√≥n t√≠pica de React, 
los datos se pasan de arriba hacia abajo (de padre a hijo) 
a trav√©s de props, 
pero esta forma puede resultar inc√≥moda para ciertos tipos de props (por ejemplo, localizaci√≥n, el tema de la interfaz) 
que son necesarias para muchos componentes dentro de una aplicaci√≥n. Context proporciona una forma de compartir valores como estos entre componentes sin tener que pasar expl√≠citamente una prop a trav√©s de cada nivel del √°rbol.

Cu√°ndo usar Context
Context est√° dise√±ado para compartir datos que pueden considerarse ‚Äúglobales‚Äù para un √°rbol de componentes en React,
 como el usuario autenticado actual, 
 el tema o el idioma preferido. 
 Por ejemplo, en el c√≥digo a continuaci√≥n, 
 pasamos manualmente una prop de ‚Äútema‚Äù para darle estilo al componente Button:
