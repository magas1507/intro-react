Si React es tu primera liberÃ­a de JavaScript, debes saber que muchas de las librerÃ­as estÃ¡n basadas en componentes, peroâ€¦ Â¿Realmente quÃ© significa un â€œcomponenteâ€? Si ya has tomado el Curso BÃ¡sico de Web Components con JavaScript pues el concepto es prÃ¡cticamente el mismo, pero aplicados a React. Pero si es la primera vez que escuchas sobre componentesâ€¦
.
â˜ BÃ¡sicamente un componente es un pedacito de tu pÃ¡gina web, es decir, puede ser una secciÃ³n especÃ­fica de tu pÃ¡gina web, o puede ser algÃºn elemento que se repita mÃºltiples veces en la misma. Lo importante a tener en cuenta es que, un componente es una parte especÃ­fica de tu pÃ¡gina, es algo que cumple una acciÃ³n simple ğŸ‘€.
.
Â¿El header de mi pÃ¡gina puede ser un componente? Â¡SÃ­!
Â¿El sidebar puede ser un componente? Â¡Por su puesto!
Y si tengo varios articulos en mi pÃ¡ginaâ€¦ Â¿Puedo convertirlos a componentes? Â¡Por su pollo! ğŸ˜„
.
Recuerda que todo puede ser un componente, y esto nos permite modularizar nuestro cÃ³digo. Es decir, podemos dividir y â€œaislarâ€ cada parte de nuestra pÃ¡gina. Si por alguna razÃ³n necesitaramos actualizar nuestro header (por ejemplo), bastarÃ­a con entrar al componente header modificar una pequeÃ±a lÃ­nea y listo! Ya no tendrÃ­amos que buscar el header dentro de tooooodo nuestro HTML UwU.
.
ğŸ‘€ Otra ventaja de los componentes es que son reutilizables, es decir, puedes usarlos cuantas veces quieras. Por ejemplo, si tuvieras un sitio web sobre blogs, ya sabes que muchos blogs suelen tener una imagen, un tÃ­tulo y una descripciÃ³n. Entonces podrÃ­amos crear un componente con la estructura de nuestro blogpost y Ãºnicamente mandarle la informaciÃ³n que necesitemos por cada blogpost y cada uno se crearÃ­a automÃ¡ticamente!!

clase 2**

Recuerden que para inicializar un proyecto de react con configuraciones predeterminadas, esto dentro de la carpeta en la que estamos introducimos el siguiente cÃ³digo en la terminal:

npx create-react-app ./
Recuerden que el " ./ " hace referencia a la carpeta en la cual nos encontramos posicionados dentro de la terminal

***clase 3
Lo increÃ­ble de JSX es que ahora estamos practicamente escribiendo todo el HTML de nuestra aplicaciÃ³n dentro de JavaScript ğŸ˜. 
A esto es a lo que nos referimos cuando decimos que â€œhoy en dÃ­a nuestras aplicaciones web ya son puro JavaScriptâ€.
Aunque la verdadera forma de trabajar con JSX es usando la funciÃ³n createElement, esta suggar syntax nos permite verlo mÃ¡s parecido a un HTML (lo cual tambiÃ©n lo hace mÃ¡s legible).
 Y ahora casi que podemos mezclar HTML con JavaScript. 
Es decir, podemos tener nuestra lÃ³gica de JavaScript y despuÃ©s en el render de JSX podemos simplemente usar variables (o usar directamente cÃ³digo JavaScript).
.
Of courseâ€¦ empiezan a entrar en juego las buenas practicas, ya que si miramos el hecho de que React nos permite combinar cÃ³digo JavaScript con nuestro HTML nos empezamos a dar cuenta queâ€¦ 
pues se va pareciendo un poquito a lo que hacian los programadores de antaÃ±o con HTML y PHP y el cÃ³digo acababa siendo una mezcla rara de dos lenguajes ğŸ˜…. 
TambiÃ©n por eso es importante mantener separada la vista de nuestra lÃ³gica en nuestras aplicaciones. 
En fin, el punto es que JSX nos permite escribir nuestra vista con una sintaxis muy parecida a HTML, pero con la oportunidad de incluir nuestro cÃ³digo JavaScript dentro, lo cual hace mÃ¡s fÃ¡cil de entender quÃ© hace cada componente ğŸ˜‰.

/***Eventos en React*/
â˜ Por si no entendiste bien por quÃ© a veces enviamos arrow functions y por quÃ© otras veces no, aquÃ­ te lo explico:
.
Cualquier evento recibe sÃ­ o sÃ­ una funciÃ³n, es decir, debemos mandarle sÃ­ o sÃ­ una funciÃ³n para que React internamente pueda ejecutarla en cuanto dicho eventop ocurre.
.
El asunto, es que tiene que ser sÃ­ o sÃ­ una funciÃ³n que React pueda ejecutar, por eso no podemos mandar directamente un console.log() ni un alert(), porque aunque ambos son funciones, nosotros estamos ejecutÃ¡ndolas directamente al ponerles los parÃ©ntesis, pero nosotros no debemos ejecutarlas, nosotros solo debemos mandarlas y ya React se encargarÃ¡ de ejecutarlas.
.
Es por eso que mandamos arrow functions, porque estas son funciones que React puede ejecutar cuando quiera, y pues dentro de esas arrow functions estÃ¡ el cÃ³digo que queremos ejecutar cuando el evento suceda.
.

onClick={() => alert("React sÃ­ puede ejecutar esta arrow function cada que le de la gana OwO")}
.
Sin embargo, recordando que los eventos reciben funciones, yo puedo crear una variable que dentro guarde una funciÃ³n, por ejemplo:
.

const adentroTengoUnaFuncion = () => {
    console.log("Hola");
    console.log("Soy una funciÃ³n que estÃ¡ siendo guardada dentro de una variable UwU");
}
.
Yo puedo ejecutar esta funciÃ³n sin problemas de esta forma adentroTengoUnaFuncion(), pero tambiÃ©n puedo mandarsela a React para que Ã©l lo ejecute cuando quiera (en este caso, cuando el evento suceda):
.

onClick={adentroTengoUnaFuncion}
.
Nota como aquÃ­ mandamos la funciÃ³n sin parÃ©ntesis, esto es porque en el momento en el que le ponemos parÃ©ntesis serÃ­amos nosotros quienes ejecutan la funciÃ³n, pero recuerda que nosotros no debemos ejecutar la funciÃ³n, sino React es quien tiene que ejecutarla. Â¿Por quÃ©? Pues porque si la ejecutamos nosotros, esta se va a ejecutar justo en el momento que esa lÃ­nea de cÃ³digo sea leÃ­da por nuestra computadora, y nosotros no queremos eso, nosotros queremos que nuestra funciÃ³n se ejecute Ãºnicamente cuando el evento suceda, por eso la mandamos sin parÃ©ntesis, para que React pueda ejecutarla cuando dicho evento ocurra ğŸ˜„
.
Peeeeeero, podemos hacer algo genial (y puede ponerse complicado), no veo razÃ³n para hacer esto, pero te lo explico por alimentar tu curiosidad jaja:
.
SÃ­ podemos ejecutar nosotros la funciÃ³n ğŸ‘€â€¦ Yo sÃ©, esto es totalmente lo contrario a lo que te acabo de decir, pero checa esto ğŸ‘‡
.
Nosotros sÃ­ podemos hacer esto:
.

onClick={adentroTengoUnaFuncion()}
Solamente sÃ­ nuestra funciÃ³n estÃ¡ asÃ­:
.

const adentroTengoUnaFuncion = () => {
    return () => {
        console.log("Hola");
        console.log("Soy una funciÃ³n que estÃ¡ siendo guardada dentro de una variable UwU");
    }
}
.
Waitâ€¦ what? Es simple ğŸ‘€ Mi funciÃ³n adentroTengoUnaFuncion estÃ¡ retornando otra funciÃ³n, eso significa que, en el momento que mi cÃ³digo se ejecute, mi funciÃ³n adentroTengoUnaFuncion tambiÃ©n se va a ejecutar inmediatamente, pero como esta funciÃ³n estÃ¡ retornando otra funciÃ³n, al final mi evento onClick acabarÃ¡ recibiendo la funciÃ³n que necesita para funcionar!!! OwO
.
Â¿Por quÃ© harÃ­amos esto? Seguramente tenga algÃºn caso de uso, pero tambiÃ©n es interesante saber que se pueden hacer este tipo de cosas UwU

***/Manejo de Estado en React*/

Para poder manejar los estados, vamos a necesitar de react el useState.

//Si quieres importar todo React para usar useState
import React from 'react';
//Lo vas a usar de esta forma:
const [searchValue, setSearchValue] = React.useState('')

//Si quieres importar unicamente useState
import { useState } from 'react';
//Lo vas a usar de esta forma: 
const [searchValue, setSearchValue] = useState('')
useState tiene dos elementos:

El valor (quien seria value)
La funcion que cambia el valor (quien seria setValue)
En useState es siempre necesario definir un valor como parametro. Puede ser un string, array, booleano o nÃºmero

const [searchValue, setSearchValue] = useState('')
const [searchValue, setSearchValue] = useState(false)
const [searchValue, setSearchValue] = useState(['Dorime', 'Ameno'])
const [searchValue, setSearchValue] = useState(0)
En la etiqueta donde vamos a manejar el evento, no debemos olvidar colocar el value que recibirÃ¡ el valor de useState. Ejemplo:

<input
  className="TodoSearch"
  placeholder="Ingresa un POYO Todo"
  value={searchValue}
	onChange={onSearchValueChange}
/>
Espero que les haya ayudado ğŸŒŸ .


/***API de almacenamiento web**/

localStorage: guarda la informaciÃ³n en memoria incluso cuando el navegador se cierre y se reabra.

sesionStorage: uarda la informacion en memoria mientras dure la sesiÃ³n de la pÃ¡gina.

Storage.setItem()
cuando recibe un nombre y valor, lo almacena o actualiza si ya existe.

Ejemplo:

storage.setItem(nombre, valor);

Storage.getItem()
Devuelve el valor cuando le pasamos el nombre.

Ejemplo

let userBackground = storage.getItem(userBackground); 

// #000000

Storage.removeItem()
Elimina el valor almacenado cuando le pasamos el nombre:

Ejemplo

let userBackground = storage.removeItem(userBackground); 

// Queda el valor por defecto en caso que exista, por lo ejemplo un background blanco.

Storage.length
Devuelve un entero que indica el nÃºmero de elementos guardados en el objeto ** Storage.**

Ejemplo

function userSettings() {
  localStorage.setItem('userBackground', '#000000');
  localStorage.setItem('font', comic sans');
  localStorage.setItem('fontSize', '18');

  localStorage.length;

 // 3
}

storage.clear();
borra todos los registros guardados en local.

*** Como aprendimos en el minuto 04:57, podemos enviarle un segundo argumento a la funciÃ³n useEffect para determinar cuÃ¡ndo ejecutamos o 
no el cÃ³digo de nuestro efecto.
.
ğŸ”‚ Podemos enviar un array vacÃ­o para decirle a nuestro efecto solo se ejecute una vez, 
cuando reciÃ©n hacemos el primer render de nuestro componente.
.
ğŸ‘‚ O tambiÃ©n podemos enviar un array con distintos elementos para decirle a nuestro efecto que no solo ejecute el efecto en el primer render, 
sino tambiÃ©n cuando haya cambios en esos elementos del array.
.
ğŸ” Si no enviamos ningÃºn array como segundo argumento de nuestro efecto, 
esta funciÃ³n se ejecutarÃ¡ cada vez que nuestro componente haga render (es decir, cada vez que haya cambios en cualquiera de nuestros estados).
.
.
â“ Â¿CuÃ¡l de estas opciones crees que debimos usar en nuestro efecto dentro de useLocalStorage?
.
Al menos por ahora, lo mejor habrÃ­a sido enviar un array vacÃ­o para que nuestro efecto solo se ejecute una vez, 
en el primer amado a nuestro custom hook / render de nuestro componente. ğŸ˜Œ
.
Lastimosamente, olvidÃ© escribir ese segundo parÃ¡metro durante la clase. 
Esto hace que el cÃ³digo de mi efecto se ejecute cada vez que hay un cambio en el estado. Y como hacemos cambios a estado dentro del efecto, 
entonces el efecto se ejecutarÃ¡ sin parar todo el tiempo que usemos la aplicaciÃ³n. ğŸ˜±.
Afortunadamente, como todo el cÃ³digo del useEffect estÃ¡ envuelto en un setTimeout, 
cada ejecuciÃ³n del cÃ³digo de efecto tarda 1 segundo en volver a ejecutarse, por lo que la app no va a crashear. ğŸ˜“
.
Â¡Este error podemos resolverlo en el siguiente curso de la saga! ğŸ™
Incluso podemos profundizar muchÃ­simo mÃ¡s en este tipo de errores en un curso de optimizaciÃ³n, rendimiento y debugging con React.js. ğŸ’š
.
.
ğŸ’ª Mientras tanto, sÃ© mejor que yo. No olvides escribir el segundo parÃ¡metro de tu efecto en useLocalStorage para que el cÃ³digo de tu efecto solo se ejecute una vez y no tengas problemas de rendimiento en tu versiÃ³n de TODO Machine.

***Aprovecho para aclarÃ¡rselos:

Una cosa es el render de React. Y otra cossa es el render en el navegador.

React ejecuta el useEffect luego del render de React, pero antes del render en el navegador.

En cambio, React ejecuta el useLayoutEffect luego del render de React y del render en el navegador.

Pregunta de examen. ğŸ˜„

**Recuerda que cuando hay mas de un estado ya no vamos a pasar un array con todos ellos, si no un objeto

Â¿QuÃ© hace useEffect? Al usar este Hook, le estamos indicando a React que el componente tiene que hacer algo despuÃ©s de renderizarse. React recordarÃ¡ la funciÃ³n que le hemos pasado (nos referiremos a ella como nuestro â€œefectoâ€), y la llamarÃ¡ mÃ¡s tarde despuÃ©s de actualizar el DOM. En este efecto, actualizamos el tÃ­tulo del documento, pero tambiÃ©n podrÃ­amos hacer peticiones de datos o invocar alguna API imperativa.

Â¿Por quÃ© se llama a useEffect dentro del componente? Poner useEffect dentro del componente nos permite acceder a la variable de estado count (o a cualquier prop) directamente desde el efecto. No necesitamos una API especial para acceder a ella, ya que se encuentra en el Ã¡mbito de la funciÃ³n. Los Hooks aprovechan los closures de JavaScript y evitan introducir APIs especÃ­ficas de React donde JavaScript ya proporciona una soluciÃ³n.

Â¿Se ejecuta useEffect despuÃ©s de cada renderizado? Â¡SÃ­! Por defecto se ejecuta despuÃ©s del primer renderizado y despuÃ©s de cada actualizaciÃ³n. MÃ¡s tarde explicaremos cÃ³mo modificar este comportamiento. En vez de pensar en tÃ©rminos de â€œmontarâ€ y â€œactualizarâ€, puede resultarte mÃ¡s fÃ¡cil pensar en efectos que ocurren â€œdespuÃ©s del renderizadoâ€. React se asegura de que el DOM se ha actualizado antes de llevar a cabo el efecto.



***React Context: estado compartido***

Context
Context provee una forma de pasar datos 
a travÃ©s del Ã¡rbol de componentes sin tener 
que pasar props manualmente en cada nivel.

En una aplicaciÃ³n tÃ­pica de React, 
los datos se pasan de arriba hacia abajo (de padre a hijo) 
a travÃ©s de props, 
pero esta forma puede resultar incÃ³moda para ciertos tipos de props (por ejemplo, localizaciÃ³n, el tema de la interfaz) 
que son necesarias para muchos componentes dentro de una aplicaciÃ³n. Context proporciona una forma de compartir valores como estos entre componentes sin tener que pasar explÃ­citamente una prop a travÃ©s de cada nivel del Ã¡rbol.

CuÃ¡ndo usar Context
Context estÃ¡ diseÃ±ado para compartir datos que pueden considerarse â€œglobalesâ€ para un Ã¡rbol de componentes en React,
 como el usuario autenticado actual, 
 el tema o el idioma preferido. 
 Por ejemplo, en el cÃ³digo a continuaciÃ³n, 
 pasamos manualmente una prop de â€œtemaâ€ para darle estilo al componente Button:
